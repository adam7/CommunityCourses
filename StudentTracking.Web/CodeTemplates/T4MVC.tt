<#
/*
T4MVC Version 2.4.03
Find latest version on http://aspnet.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=24471&ProjectName=aspnet

Written by David Ebbo, with much feedback from the MVC community (thanks all!)
david.ebbo@microsoft.com
http://twitter.com/davidebbo
http://blogs.msdn.com/davidebb

Feel free to use and modify to fit your needs.

NOTE: all the documentation and versioning information that used to be in this file has been moved
to the readme.txt file (found in the same zip file on CodePlex) as of version 2.4.03. Please check the
readme for all the details!
*/
#>
<#@ template language="C#v3.5" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<# PrepareDataToRender(this); #>
// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

// Make sure the compiler doesn't complain about missing Xml comments
#pragma warning disable 1591
#region T4MVC

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Web;
using System.Web.Mvc;
using System.Web.Mvc.Ajax;
using System.Web.Mvc.Html;
using System.Web.Routing;
using <#= T4MVCNamespace #>;

[CompilerGenerated]
public static class <#= HelpersPrefix #> {
<#  foreach (var controller in GetControllers()) { #>
    public static <#= controller.FullClassName #> <#= controller.Name #> = new <#= controller.DerivedClassName #>();
<#  } #>
}

<#  foreach (var controller in GetAbstractControllers().Where(c => !c.HasDefaultConstructor)) { #>
namespace <#= controller.Namespace #> {
    public partial class <#= controller.ClassName #> {
        protected <#= controller.ClassName #>() { }
    }
}
<#  } #>

<#      foreach (var controller in GetControllers()) { #>
namespace <#= controller.Namespace #> {
    public <# if (!controller.SharedViewFolder) { #>partial <# } #>class <#= controller.ClassName #> {

<#      if (!controller.SharedViewFolder) { #>
<#          if (!controller.HasExplicitConstructor) { #>
        public <#= controller.ClassName #>() { }

<#          } #>
        [CompilerGenerated]
        protected <#= controller.ClassName #>(Dummy d) { }

        protected RedirectToRouteResult RedirectToAction(ActionResult result) {
            var callInfo = (IT4MVCActionResult)result;
            return RedirectToRoute(callInfo.RouteValues);
        }

<#      foreach (var method in controller.ActionMethodsUniqueWithoutParameterlessOverload) { #>
        [NonAction]
        public ActionResult <#= method.Name #>() {
            return new T4MVC_ActionResult(Name, Actions.<#= method.ActionName #>);
        }

<#      } #>

        [CompilerGenerated]
        public readonly string Name = "<#= controller.Name #>";

        static readonly ActionNames s_actions = new ActionNames();
        [CompilerGenerated]
        public ActionNames Actions { get { return s_actions; } }
        [CompilerGenerated]
        public class ActionNames {
<#          foreach (var method in controller.ActionMethodsWithUniqueNames) { #>
            public readonly string <#= method.ActionName #> = <#= method.ActionNameValueExpression #>;
<#          } #>
        }

<#      } #>

        static readonly ViewNames s_views = new ViewNames();
        [CompilerGenerated]
        public ViewNames Views { get { return s_views; } }
        [CompilerGenerated]
        public class ViewNames {
<#      RenderControllerViews(controller);#>
        }
    }
}
<#  } #>

namespace <#= T4MVCNamespace #> {
<#  foreach (var controller in GetControllers().Where(c => !c.SharedViewFolder)) { #>
    [CompilerGenerated]
    public class <#= controller.DerivedClassName #>: <#= controller.FullClassName #> {
        public <#= controller.DerivedClassName #>() : base(Dummy.Instance) { }

<#      foreach (var method in controller.ActionMethods) { #>
        public override <#= method.ReturnTypeFullName #> <#= method.Name #>(<# method.WriteFormalParameters(true); #>) {
            var callInfo = new T4MVC_<#= method.ReturnType #>("<#= controller.Name #>", Actions.<#= method.ActionName #>);
<#          if (method.Parameters.Count > 0) { #>
<#              foreach (var p in method.Parameters) { #>
            callInfo.RouteValues.Add("<#= p.Name #>", <#= p.Name #>);
<#              } #>
<#          }#>
            return callInfo;
        }

<#      } #>
    }
<#  } #>

    [CompilerGenerated]
    public class Dummy {
        private Dummy() { }
        public static Dummy Instance = new Dummy();
    }
}

namespace System.Web.Mvc {
    [CompilerGenerated]
    public static class T4Extensions {
        public static string ActionLink(this HtmlHelper htmlHelper, string linkText, ActionResult result) {
            return htmlHelper.RouteLink(linkText, result.GetRouteValueDictionary());
        }

        public static string ActionLink(this HtmlHelper htmlHelper, string linkText, ActionResult result, object htmlAttributes) {
            return ActionLink(htmlHelper, linkText, result, new RouteValueDictionary(htmlAttributes));
        }

        public static string ActionLink(this HtmlHelper htmlHelper, string linkText, ActionResult result, IDictionary<string, object> htmlAttributes) {
            return htmlHelper.RouteLink(linkText, result.GetRouteValueDictionary(), htmlAttributes);
        }

        public static MvcForm BeginForm(this HtmlHelper htmlHelper, ActionResult result, FormMethod formMethod) {
            return htmlHelper.BeginForm(result, formMethod, null);
        }

        public static MvcForm BeginForm(this HtmlHelper htmlHelper, ActionResult result, FormMethod formMethod, object htmlAttributes) {
            return BeginForm(htmlHelper, result, formMethod, new RouteValueDictionary(htmlAttributes));
        }

        public static MvcForm BeginForm(this HtmlHelper htmlHelper, ActionResult result, FormMethod formMethod, IDictionary<string, object> htmlAttributes) {
            var callInfo = (IT4MVCActionResult)result;
            return htmlHelper.BeginForm(callInfo.Action, callInfo.Controller, callInfo.RouteValues, formMethod, htmlAttributes);
        }

        public static string Action(this UrlHelper urlHelper, ActionResult result) {
            return urlHelper.RouteUrl(result.GetRouteValueDictionary());
        }

        public static string ActionLink(this AjaxHelper ajaxHelper, string linkText, ActionResult result, AjaxOptions ajaxOptions) {
            return ajaxHelper.RouteLink(linkText, result.GetRouteValueDictionary(), ajaxOptions);
        }

        public static string ActionLink(this AjaxHelper ajaxHelper, string linkText, ActionResult result, AjaxOptions ajaxOptions, object htmlAttributes) {
            return ajaxHelper.RouteLink(linkText, result.GetRouteValueDictionary(), ajaxOptions, new RouteValueDictionary(htmlAttributes));
        }

        public static string ActionLink(this AjaxHelper ajaxHelper, string linkText, ActionResult result, AjaxOptions ajaxOptions, IDictionary<string, object> htmlAttributes) {
            return ajaxHelper.RouteLink(linkText, result.GetRouteValueDictionary(), ajaxOptions, htmlAttributes);
        }

        public static Route MapRoute(this RouteCollection routes, string name, string url, ActionResult result) {
            return routes.MapRoute(name, url, result, (ActionResult)null);
        }

        public static Route MapRoute(this RouteCollection routes, string name, string url, ActionResult result, object defaults) {
            // Start by adding the default values from the anonymous object (if any)
            var routeValues = new RouteValueDictionary(defaults);

            // Then add the Controller/Action names and the parameters from the call
            foreach (var pair in result.GetRouteValueDictionary()) {
                routeValues.Add(pair.Key, pair.Value);
            }

            // Create and add the route
            var route = new Route(url, routeValues, new MvcRouteHandler());
            routes.Add(name, route);
            return route;
        }

        public static RouteValueDictionary GetRouteValueDictionary(this ActionResult result) {
            return ((IT4MVCActionResult)result).RouteValues;
        }

        public static void InitMVCT4Result(this IT4MVCActionResult result, string controller, string action) {
            result.Controller = controller;
            result.Action = action; ;
            result.RouteValues = new RouteValueDictionary();
            result.RouteValues.Add("Controller", controller);
            result.RouteValues.Add("Action", action);
        }
    }
}

[CompilerGenerated]
public interface IT4MVCActionResult {
    string Action { get; set; }
    string Controller { get; set; }
    RouteValueDictionary RouteValues { get; set; }
}

<# foreach (var resultType in ResultTypes.Values) { #>
[CompilerGenerated]
public class T4MVC_<#= resultType.Name #> : <#= resultType.FullName #>, IT4MVCActionResult {
    public T4MVC_<#= resultType.Name #>(string controller, string action): base(<# resultType.Constructor.WriteNonEmptyParameterValues(true); #>)  {
        this.InitMVCT4Result(controller, action);
    }
    <# foreach (var method in resultType.AbstractMethods) { #> 
    <#= method.IsPublic ? "public" : "protected" #> override void <#= method.Name #>(<# method.WriteFormalParameters(true); #>) { }
    <# } #>

    public string Controller { get; set; }
    public string Action { get; set; }
    public RouteValueDictionary RouteValues { get; set; }
}

<# } #>

namespace <#= LinksNamespace #> {
<#
    foreach (string folder in StaticFilesFolders) {
        ProcessStaticFiles(Project, folder);
    }
#>
}

<#
      RenderAdditionalCode();
#>

#endregion T4MVC
#pragma warning restore 1591

<#@ Include File="T4MVC.settings.t4" #>

<#+ 
const string T4MVCNamespace = "T4MVC";
const string ControllerSuffix = "Controller";

static DTE Dte;
static Project Project;
static HashSet<ControllerInfo> Controllers;
static Dictionary<string, ResultTypeInfo> ResultTypes;
static TextTransformation TT;
static string T4FileName;

static IEnumerable<ControllerInfo> GetControllers() {
    return Controllers.Where(c => !c.IsAbstract);
}

static IEnumerable<ControllerInfo> GetAbstractControllers() {
    return Controllers.Where(c => c.IsAbstract);
}

void PrepareDataToRender(TextTransformation tt) {

    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    Controllers = new HashSet<ControllerInfo>();
    ResultTypes = new Dictionary<string, ResultTypeInfo>();

    // Get the DTE service from the host
    Dte = (DTE)((IServiceProvider)Host).GetService(typeof(SDTE));

    Project = GetProjectContainingT4File(Dte);
    if (Project == null) {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }

    ProcessControllersFolder(Project);
    ProcessAllViews(Project);
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
    
    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    if (AlwaysKeepTemplateDirty) {
        // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
        // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
        // Note: this is certainly hacky, but is the best I could come up with so far.
        projectItem.Document.Saved = false;
    }
    
    return projectItem.ContainingProject;
}

void ProcessControllersFolder(Project project) {
    // Get the Controllers folder
    ProjectItem controllerProjectItem = GetProjectItem(project, ControllersFolder);
    if (controllerProjectItem == null)
        return;

    ProcessControllersRecursive(controllerProjectItem);
}

void ProcessControllersRecursive(ProjectItem projectItem) {

    // Recurse into all the sub-items (both files and folder can have some - e.g. .tt files)
    foreach (ProjectItem item in projectItem.ProjectItems) {
        ProcessControllersRecursive(item);
    }

    if (projectItem.FileCodeModel != null) {
        // Process all the elements that are namespaces
        foreach (CodeNamespace ns in GetNamespaces(projectItem.FileCodeModel.CodeElements)) {
            ProcessControllerTypesInNamespace(ns);
        }
    }
}

void ProcessControllerTypesInNamespace(CodeNamespace ns) {
    foreach (CodeClass2 type in GetClasses(ns.Members)) {

        // Only process types that end with Controller
        // REVIEW: this check is not super reliable. Should look at base class.
        if (!type.Name.EndsWith(ControllerSuffix, StringComparison.OrdinalIgnoreCase))
            continue;

        // Don't process generic classes (their concrete derived classes will be processed)
        if (type.IsGeneric)
            continue;

        // Make sure the class is partial
        if (type.ClassKind != vsCMClassKind.vsCMClassKindPartialClass) {
            try {
                type.ClassKind = vsCMClassKind.vsCMClassKindPartialClass;
            }
            catch {
                // If we couldn't make it partial, give a warning and skip it
                Warning(String.Format("{0} was not able to make the class {1} partial. Please change it manually if possible", T4FileName, type.Name));
                continue;
            }
            Warning(String.Format("{0} changed the class {1} to be partial", T4FileName, type.Name));
        }

        // Collect misc info about the controller class and add it to the collection
        var controllerInfo = new ControllerInfo() {
            Namespace = ns.Name,
            ClassName = type.Name
        };

        // Either process new ControllerInfo or integrate results into existing object for partially defined controllers
        var target = Controllers.Add(controllerInfo) ? controllerInfo : Controllers.First(c => c.Equals(controllerInfo));
        target.HasExplicitConstructor |= HasExplicitConstructor(type);
        target.HasExplicitDefaultConstructor |= HasExplicitDefaultConstructor(type);

        if (type.IsAbstract) {
            // If it's abstract, set a flag and don't process action methods (derived classes will)
            target.IsAbstract = true;
        }
        else {
            // Process all the action methods in the controller
            ProcessControllerActionMethods(target, type);
        }
    }
}

void ProcessControllerActionMethods(ControllerInfo controllerInfo, CodeClass2 current) {

    // We want to process not just the controller class itself, but also its parents, as they
    // may themselves define actions
    for (CodeClass2 type = current; type != null && type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2)type.Bases.Item(1)) {

        // If the type doesn't come from this project, some actions on it will fail. Try to get a real project type if possible.
        if (type.InfoLocation != vsCMInfoLocation.vsCMInfoLocationProject) {
            // Go through all the projects in the solution
            foreach (Project prj in Dte.Solution.Projects) {
                // Skip it if it's the current project or doesn't have a code model
                if (prj == Project || prj.CodeModel == null)
                    continue;
                
                // If we can get a local project type, use it instead of the original
                var codeType = prj.CodeModel.CodeTypeFromFullName(type.FullName);
                if (codeType != null && codeType.InfoLocation == vsCMInfoLocation.vsCMInfoLocationProject) {
                    type = (CodeClass2)codeType;
                    break;
                }
            }
        }

        foreach (CodeFunction2 method in GetMethods(type)) {
            // Ignore non-public methods
            if (method.Access != vsCMAccess.vsCMAccessPublic)
                continue;

            // This takes care of avoiding generic types which cause method.Type.CodeType to blow up
            if (method.Type.TypeKind != vsCMTypeRef.vsCMTypeRefCodeType)
                continue;

            // We only support action methods that return an ActionResult derived type
            if (!method.Type.CodeType.get_IsDerivedFrom("System.Web.Mvc.ActionResult")) {
                Warning(String.Format("{0} doesn't support {1}.{2} because it doesn't return a supported ActionResult type", T4FileName, type.Name, method.Name));
                continue;
            }

            // If we haven't yet seen this return type, keep track of it
            if (!ResultTypes.ContainsKey(method.Type.CodeType.Name)) {
                var resTypeInfo = new ResultTypeInfo(method.Type.CodeType);

                ResultTypes[method.Type.CodeType.Name] = resTypeInfo;
            }

            // Make sure the method is virtual
            if (!method.CanOverride) {
                try {
                    method.CanOverride = true;
                }
                catch {
                    // If we couldn't make it virtual, give a warning and skip it
                    Warning(String.Format("{0} was not able to make the action method {1}.{2} virtual. Please change it manually if possible", T4FileName, type.Name, method.Name));
                    continue;
                }
                Warning(String.Format("{0} changed the action method {1}.{2} to be virtual", T4FileName, type.Name, method.Name));
            }

            // Collect misc info about the action method and add it to the collection
            controllerInfo.ActionMethods.Add(new ActionMethodInfo(method, controllerInfo));
        }
    }
}

void ProcessAllViews(Project project) {
    // Get the Views folder
    ProjectItem viewsProjectItem = GetProjectItem(project, ViewsRootFolder);
    if (viewsProjectItem == null)
        return;

    // Go through all the sub-folders in the Views folder
    foreach (ProjectItem item in viewsProjectItem.ProjectItems) {

        // We only care about sub-folders, not files
        if (!IsFolder(item))
            continue;

        ControllerInfo controller;
        // Treat Shared as a pseudo-controller for consistency
        if (item.Name.Equals("Shared", StringComparison.OrdinalIgnoreCase)) {
            controller = new ControllerInfo() { SharedViewFolder = true, Namespace = T4MVCNamespace, ClassName = "Shared" + ControllerSuffix };
            Controllers.Add(controller);
        }
        else {
            // Find the controller for this view folder
            controller = Controllers.SingleOrDefault(c => c.Name.Equals(item.Name, StringComparison.OrdinalIgnoreCase));

            if (controller == null) {
                Error(String.Format("The Views folder has a sub-folder named '{0}', but there is no matching controller", item.Name));
                continue;
            }
        }

        AddViewsRecursive(String.Empty, item.ProjectItems, controller.ViewsFolder);
    }
}

void AddViewsRecursive(string prefix, ProjectItems items, ViewsFolderInfo viewsFolder) {
    // Go through all the files in the subfolder to get the view names
    foreach (ProjectItem item in items) {
        string viewName = Path.GetFileNameWithoutExtension(item.Name);
        if (item.Kind == Constants.vsProjectItemKindPhysicalFile) {
            if (Path.GetExtension(item.Name).Equals(".master", StringComparison.OrdinalIgnoreCase))
                continue;	// ignore master files
            viewsFolder.Views.Add(viewName);
        }
        else if (item.Kind == Constants.vsProjectItemKindPhysicalFolder) {
            var subViewFolder = new ViewsFolderInfo() { FullName = prefix + viewName };
            if (subViewFolder.Name.Equals("App_LocalResources", StringComparison.OrdinalIgnoreCase))
                continue;
            viewsFolder.SubFolders.Add(subViewFolder);
            AddViewsRecursive(prefix + viewName + "/", item.ProjectItems, subViewFolder);
        }
    }
}

void RenderControllerViews(ControllerInfo controller) {
    PushIndent("            ");
    RenderViewsRecursive(controller.ViewsFolder);
    PopIndent();
}

void RenderViewsRecursive(ViewsFolderInfo viewsFolder) {

    // For each view, generate a readonly string
    foreach (string view in viewsFolder.Views) {
        WriteLine("public readonly string " + Sanitize(view) + " = \"" + viewsFolder.GetFullViewName(view) + "\";");
    }

    // For each sub folder, generate a class and recurse
    foreach (var subFolder in viewsFolder.SubFolders) {
        string newClassName = Sanitize(subFolder.Name);#>
static readonly _<#=newClassName#> s_<#=newClassName#> = new _<#=newClassName#>();
public _<#=newClassName#> <#=newClassName#> { get { return s_<#=newClassName#>; } }
public partial class _<#=newClassName#>{
<#+
        PushIndent("    ");
        RenderViewsRecursive(subFolder);
        PopIndent();

        WriteLine("}");
    }
}

void ProcessStaticFiles(Project project, string folder) {

    ProjectItem folderProjectItem = GetProjectItem(project, folder);
    if (folderProjectItem != null) {
        ProcessStaticFilesRecursive(folderProjectItem, "~");
    }
}

void ProcessStaticFilesRecursive(ProjectItem projectItem, string path) {

    if (IsFolder(projectItem)) { #>
    [CompilerGenerated]
    public static class @<#=Sanitize(projectItem.Name) #> {
        public static string Url() { return T4MVCHelpers.ProcessVirtualPath("<#=path#>/<#=projectItem.Name#>"); }
        public static string Url(string fileName) { return T4MVCHelpers.ProcessVirtualPath("<#=path#>/<#=projectItem.Name#>/" + fileName); }
<#+
        PushIndent("    ");
        
        // Recurse into all the items in the folder
        foreach (ProjectItem item in projectItem.ProjectItems) {
            ProcessStaticFilesRecursive(item, path + "/" + projectItem.Name);
        }

        PopIndent();
#>
    }

<#+
    }
    else { #>
    public static readonly string <#=Sanitize(projectItem.Name)#> = Url("<#=projectItem.Name#>");
<#+
        // Non folder items may also have children (virtual folders, Class.cs -> Class.Designer.cs, template output)
        // Just register them on the same path as their parent item
        foreach (ProjectItem item in projectItem.ProjectItems) {
            ProcessStaticFilesRecursive(item, path);
        }
    }
}

ProjectItem GetProjectItem(Project project, string name) {
    return GetProjectItem(project.ProjectItems, name);
}

ProjectItem GetProjectItem(ProjectItems items, string subPath) {

    ProjectItem current = null;
    foreach (string name in subPath.Split('\\')) {
        try {
            // ProjectItems.Item() throws when it doesn't exist, so catch the exception
            // to return null instead.
            current = items.Item(name);
        }
        catch {
            // If any chunk couldn't be found, fail
            return null;
        }
        items = current.ProjectItems;
    }

    return current;
}

// Return all the CodeNamespaces in the CodeElements collection
static IEnumerable<CodeNamespace> GetNamespaces(CodeElements codeElements) {
    return GetElements<CodeNamespace>(codeElements);
}

// Return all the CodeClass2 in the CodeElements collection
static IEnumerable<CodeClass2> GetClasses(CodeElements codeElements) {
    return GetElements<CodeClass2>(codeElements);
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass) {
    // Only look at regular method (e.g. ignore things like contructors)
    return GetElements<CodeFunction2>(codeClass.Members)
        .Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionFunction);
}

// Check if the class has any explicit constructor
static bool HasExplicitConstructor(CodeClass2 codeClass) {
    return GetElements<CodeFunction2>(codeClass.Members).Any(
        f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
}

// Check if the class has a default (i.e. no params) constructor
static bool HasExplicitDefaultConstructor(CodeClass2 codeClass) {
    return GetElements<CodeFunction2>(codeClass.Members).Any(
        f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor && f.Parameters.Count == 0);
}

// Find a method with a given name
static CodeFunction2 GetMethod(CodeClass2 codeClass, string name) {
    return GetMethods(codeClass).FirstOrDefault(f => f.Name == name);
}

static IEnumerable<T> GetElements<T>(CodeElements codeElements) where T : class {

    // Note: this code can be simplified to just:
    //  return codeElements.OfType<T>();
    // But this breaks on VS2010 beta due to a VS bug (that should be fixed in VS2010 beta 2).
    // For now, work around using this alternate code which avoids getting the enumerator

    for (int i = 1; i <= codeElements.Count; i++) {
        var codeNamespace = codeElements.Item(i) as T;

        if (codeNamespace != null)
            yield return codeNamespace;
    }
}

// Return whether a ProjectItem is a folder and not a file
static bool IsFolder(ProjectItem item) {
    return (item.Kind == Constants.vsProjectItemKindPhysicalFolder);
}

static string Sanitize(string token) {
    // Replace all invalid chars by underscores
    token = Regex.Replace(token, @"[\W\b]", "_", RegexOptions.IgnoreCase);

    // If it starts with a digit, prefix it with an underscore
    token = Regex.Replace(token, @"^\d", @"_$0");

    // Check for reserved words
    // TODO: Clean this up and add other reserved words (keywords, etc)
    if (token == "Url") token = "_Url";

    return token;
}

// Data structure to collect data about a controller class
class ControllerInfo {
    public ControllerInfo() {
        ActionMethods = new HashSet<ActionMethodInfo>();
        ViewsFolder = new ViewsFolderInfo();
    }

    // True when this is not a real controller, but a placeholder for the Shared views folder
    public bool SharedViewFolder { get; set; }

    public bool HasExplicitConstructor { get; set; }
    public bool HasExplicitDefaultConstructor { get; set; }
    public bool HasDefaultConstructor { get { return !HasExplicitConstructor || HasExplicitDefaultConstructor; } }
    public bool IsAbstract { get; set; }

    public string ClassName { get; set; }
    public string Name {
        get {
            // Trim the Controller suffix
            return ClassName.Substring(0, ClassName.Length - ControllerSuffix.Length);
        }
    }

    public string Namespace { get; set; }

    public string FullClassName {
        get {
            return Namespace + "." + ClassName;
        }
    }

    public string DerivedClassName {
        get {
            if (SharedViewFolder)
                return FullClassName;
            return "T4MVC_" + ClassName;
        }
    }

    public HashSet<ActionMethodInfo> ActionMethods { get; set; }

    IEnumerable<ActionMethodInfo> ActionMethodsWithNoParameters {
        get {
            return ActionMethods.Where(m => m.Parameters.Count == 0);
        }
    }

    public IEnumerable<ActionMethodInfo> ActionMethodsUniqueWithoutParameterlessOverload {
        get {
            return ActionMethodsWithUniqueNames.Except(ActionMethodsWithNoParameters, new ActionComparer());
        }
    }

    // Return a list of actions without duplicate names (even with multiple overloads)
    public IEnumerable<ActionMethodInfo> ActionMethodsWithUniqueNames {
        get {
            return ActionMethods.Distinct(new ActionComparer());
        }
    }

    class ActionComparer : IEqualityComparer<ActionMethodInfo> {
        public bool Equals(ActionMethodInfo x, ActionMethodInfo y) {
            return x.ActionName == y.ActionName;
        }

        public int GetHashCode(ActionMethodInfo obj) {
            return obj.ActionName.GetHashCode();
        }
    }

    public ViewsFolderInfo ViewsFolder { get; private set; }

    public override string ToString() {
        return Name;
    }

    public override bool Equals(object obj) {
        return obj != null && FullClassName == ((ControllerInfo)obj).FullClassName;
    }

    public override int GetHashCode() {
        return FullClassName.GetHashCode();
    }
}

// Info about a view folder, its views and its sub view folders
class ViewsFolderInfo {
    public ViewsFolderInfo() {
        Views = new HashSet<string>();
        SubFolders = new List<ViewsFolderInfo>();
    }

    public string FullName { get; set; }
    public string Name {
        get {
            return FullName.Substring(FullName.LastIndexOf("/") + 1);
        }
    }
    public HashSet<string> Views { get; private set; }
    public List<ViewsFolderInfo> SubFolders { get; set; }

    public string GetFullViewName(string viewName) {
        if (String.IsNullOrEmpty(FullName))
            return viewName;

        return FullName + "/" + viewName;
    }
}

// Data structure to collect data about a method
class FunctionInfo {
    protected CodeFunction2 _method;
    private string _signature;
    
    public FunctionInfo(CodeFunction2 method) {
        _method = method;
        
        // Build a unique signature for the method, used to avoid duplication
        _signature = method.Name;

        // Process all the parameters
        Parameters = new List<MethodParamInfo>();
        foreach (var p in GetElements<CodeParameter2>(method.Parameters)) {
            Parameters.Add(
                new MethodParamInfo() {
                    Name = p.Name,
                    Type = p.Type.AsString
                });
            _signature += "," + p.Type.AsString;
        }
    }

    public string Name { get { return _method.Name; } }
    public string ReturnType { get { return _method.Type.CodeType.Name; } }
    public string ReturnTypeFullName { get { return _method.Type.CodeType.FullName; } }
    public bool IsPublic { get { return _method.Access == vsCMAccess.vsCMAccessPublic; } }
    public List<MethodParamInfo> Parameters { get; private set; }

    // Write out all the parameters as part of a method declaration
    public void WriteFormalParameters(bool first) {
        foreach (var p in Parameters) {
            if (first)
                first = false;
            else
                TT.Write(", ");

            TT.Write(p.Type + " " + p.Name);
        }
    }

    // Pass non-empty param values to make sure the ActionResult ctors don't complain
    // REVIEW: this is a bit dirty
    public void WriteNonEmptyParameterValues(bool first) {
        foreach (var p in Parameters) {
            if (first)
                first = false;
            else
                TT.Write(", ");

            switch (p.Type) {
                case "string":
                    TT.Write("\" \"");
                    break;
                case "byte[]":
                    TT.Write("new byte[0]");
                    break;
                default:
                    TT.Write("null");
                    break;
            }
        }
    }

    public override bool Equals(object obj) {
        return obj != null && _signature == ((FunctionInfo)obj)._signature;
    }
    
    public override int GetHashCode() {
        return _signature.GetHashCode();
    }
}

// Data structure to collect data about an action method
class ActionMethodInfo: FunctionInfo {
    public ActionMethodInfo(CodeFunction2 method, ControllerInfo controller): base(method) {
        // Normally, the action name is the method name. But if there is an [ActionName] on
        // the method, get the expression from that instead
        ActionNameValueExpression = '"' + Name + '"';
        for (int i = 1; i <= method.Attributes.Count; i++) {
            var attrib = (CodeAttribute2)method.Attributes.Item(i);
            if (attrib.FullName == "System.Web.Mvc.ActionNameAttribute") {
                var arg = (CodeAttributeArgument)attrib.Arguments.Item(1);
                ActionNameValueExpression = arg.Value;
            }
        }
    }

    public string ActionName { get { return Name; } }
    public string ActionNameValueExpression { get; set; }
}

// Data about an ActionResult derived type
class ResultTypeInfo {
    CodeType _codeType;
    public ResultTypeInfo(CodeType codeType) {
        _codeType = codeType;

        var ctor = GetElements<CodeFunction2>(_codeType.Members).FirstOrDefault(
            f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
        Constructor = new FunctionInfo(ctor);
    }

    public string Name { get { return _codeType.Name; } }
    public string FullName { get { return _codeType.FullName; } }
    public FunctionInfo Constructor { get; set; }
    public IEnumerable<FunctionInfo> AbstractMethods {
        get {
            return GetElements<CodeFunction2>(_codeType.Members).Where(
                f => f.MustImplement).Select(f => new FunctionInfo(f));
        }
    }
}

class MethodParamInfo {
    public string Name { get; set; }
    public string Type { get; set; }
}

#>
